"""
TransactionPlan Model - Unsigned, custody-safe execution plan

Represents the deterministic swap execution plan generated by the agent.
This entity is IMMUTABLE and enforces custody safety properties:
- NO signatures are included
- NO funds are moved during planning
- MUST include custody proofs
- MUST include explicit custody boundary statement
- Output is deterministic (identical inputs produce byte-identical plans)
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Literal, Optional
from uuid import uuid4


@dataclass(frozen=True)
class TransactionStep:
    """
    Represents a single atomic operation in the transaction plan sequence.
    
    Properties:
    - NO private keys or signatures
    - NO fund movement during planning
    - Sequential dependency tracking for execution order
    - Fallback strategies for error handling
    """
    
    # Identification
    step_id: int  # Sequential step number (1, 2, 3, ...)
    step_type: Literal[
        "approve_token",      # Approve spending (router allowance)
        "execute_swap",       # Execute swap via DEX
        "verify_receipt",     # Verify swap completed
        "custody_proof_verify",  # Verify custody proof still valid
    ] = "execute_swap"
    
    # Target
    target_address: str = ""  # Contract address (must be on router allowlist)
    function_name: str = ""   # Function to call (e.g., "swapExactTokensForTokens")
    
    # Parameters - NO SIGNATURES allowed
    parameters: Dict[str, str] = field(default_factory=dict)  # NO private keys!
    gas_budget: int = 0  # Gas budget for this step
    
    # Contingency
    fallback_strategy: Optional[str] = None  # If step fails, use this
    depends_on: Optional[int] = None  # Step ID this depends on
    
    def validate(self) -> bool:
        """
        Validate that step contains no signatures or secret material
        
        Returns:
            bool: True if valid (no secrets), False if suspicious
        """
        # Forbidden keywords that indicate secret/signature data
        forbidden_keywords = ["private_key", "secret", "mnemonic", "seed", "signature", "signature_v", "signature_r", "signature_s"]
        
        for key, value in self.parameters.items():
            value_lower = str(value).lower()
            for keyword in forbidden_keywords:
                if keyword in key.lower() or keyword in value_lower:
                    return False
        return True


@dataclass(frozen=True)
class TransactionPlan:
    """
    Represents the unsigned, custody-safe swap execution plan.
    
    IMMUTABLE: Once generated, cannot be modified. If plan needs changes,
    user must reject and request new plan (forces re-validation).
    
    Custody-Safe Properties:
    - NO signatures included (plan is unsigned)
    - NO funds moved during planning
    - MUST include custody proofs demonstrating user control
    - MUST include explicit custody boundary statement (exact text)
    - MUST have execution_window > current_time
    - MUST have approval_required = True (human sign-off)
    
    Privacy Properties:
    - Routing through N>3 intermediate addresses OR
    - Zero-knowledge proof included
    - Transaction intent never exposed in plaintext logs
    
    Determinism Properties:
    - Identical validated quotes produce byte-identical plans
    - Output hash can be verified for reproducibility
    """
    
    # Identification
    plan_id: str = field(default_factory=lambda: str(uuid4()), init=False)
    quote_id: str = ""  # Reference to validated SwapQuote
    agent_version: str = "0.1.0"
    generated_at: str = field(default_factory=lambda: datetime.utcnow().isoformat(), init=False)
    
    # Routing
    routing_strategy: Literal[
        "direct_swap",
        "liquidity_pool",
        "dex_aggregator",
        "bridge_assisted"
    ] = "direct_swap"
    
    intermediate_addresses: List[str] = field(default_factory=list)  # N>3 for privacy
    privacy_level: int = 1  # 1=none, 2=minimal, 3=high
    
    # Execution sequence
    steps: List[TransactionStep] = field(default_factory=list)
    timing_sequence: Dict[str, str] = field(default_factory=dict)  # Timing per step
    execution_window: str = field(default_factory=lambda: (datetime.utcnow() + timedelta(hours=24)).isoformat(), init=False)
    
    # Custody
    custody_proofs: List = field(default_factory=list)  # List of CustodyProof objects
    custody_boundaries: str = "No signatures are applied; no funds are moved; user retains full control; plan is reversible until user authorization"
    
    # Execution info
    estimated_gas_cost: Decimal = Decimal("0")  # Estimated total gas (ETH)
    estimated_fee_percentage: Decimal = Decimal("0")  # Fee as % of swap
    
    # Plan status
    status: Literal["DRAFT", "PENDING_APPROVAL", "EXECUTED", "EXPIRED"] = "DRAFT"
    approval_required: bool = True  # MUST be True (human sign-off required)
    
    def is_valid(self) -> bool:
        """
        Validate that plan maintains custody safety and privacy properties
        
        Returns:
            bool: True if plan is valid
        """
        # Check: Must include custody proofs
        if not self.custody_proofs:
            return False
        
        # Check: Must have custody boundaries statement
        if self.custody_boundaries != "No signatures are applied; no funds are moved; user retains full control; plan is reversible until user authorization":
            return False
        
        # Check: Requirements: approval_required must be True
        if not self.approval_required:
            return False
        
        # Check: Execution window must be in future
        expiry = datetime.fromisoformat(self.execution_window)
        if datetime.utcnow() > expiry:
            return False
        
        # Check: Privacy level - must be >=3 intermediaries OR have ZKP
        if len(self.intermediate_addresses) >= 3:
            return True
        
        # Check for ZKP in custody proofs
        has_zkp = any(proof.proof_type == "zero_knowledge_proof" for proof in self.custody_proofs)
        return has_zkp
    
    def has_signatures(self) -> bool:
        """
        Check if plan contains any signatures (should always be False)
        
        Returns:
            bool: True if signatures found (INVALID), False if no signatures
        """
        for step in self.steps:
            if not step.validate():
                return True
        return False
    
    def get_hash(self) -> str:
        """
        Get deterministic hash of plan for reproducibility testing
        
        Returns:
            str: SHA256 hash of plan content
        """
        import hashlib
        import json
        
        plan_dict = {
            "quote_id": self.quote_id,
            "routing_strategy": self.routing_strategy,
            "intermediate_addresses": sorted(self.intermediate_addresses),
            "estimated_gas_cost": str(self.estimated_gas_cost),
            "estimated_fee_percentage": str(self.estimated_fee_percentage),
        }
        
        plan_str = json.dumps(plan_dict, sort_keys=True)
        return hashlib.sha256(plan_str.encode()).hexdigest()
    
    def to_dict(self) -> dict:
        """Convert plan to API response dict (without internal objects)"""
        return {
            "plan_id": self.plan_id,
            "quote_id": self.quote_id,
            "status": self.status,
            "routing_strategy": self.routing_strategy,
            "privacy_level": self.privacy_level,
            "intermediate_addresses": self.intermediate_addresses,
            "estimated_gas_cost": str(self.estimated_gas_cost),
            "estimated_fee_percentage": str(self.estimated_fee_percentage),
            "execution_window": self.execution_window,
            "custody_boundaries": self.custody_boundaries,
            "approval_required": self.approval_required,
            "steps_count": len(self.steps),
            "custody_proofs_count": len(self.custody_proofs),
        }
